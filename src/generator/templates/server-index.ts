import type { ServerConfig } from '../types.js';

export function generateServerIndex(config: ServerConfig): string {
  const capabilities: string[] = [];

  if (config.capabilities.tools) {
    capabilities.push(`tools: { listChanged: ${config.features.listChanged} }`);
  }
  if (config.capabilities.resources) {
    const resourceCaps = ['subscribe: ' + config.features.subscribe, 'listChanged: ' + config.features.listChanged];
    capabilities.push(`resources: { ${resourceCaps.join(', ')} }`);
  }
  if (config.capabilities.prompts) {
    capabilities.push(`prompts: { listChanged: ${config.features.listChanged} }`);
  }

  const imports: string[] = [
    `import { Server } from '@modelcontextprotocol/sdk/server/index';`,
    `import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio';`,
  ];

  if (config.capabilities.tools) {
    imports.push(
      `import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types';`,
      `import { listTools, callTool } from './tools/index.js';`
    );
  }

  if (config.capabilities.resources) {
    imports.push(
      `import { ListResourcesRequestSchema, ReadResourceRequestSchema } from '@modelcontextprotocol/sdk/types';`,
      `import { listResources, readResource } from './resources/index.js';`
    );
    if (config.features.subscribe) {
      imports.push(
        `import { SubscribeRequestSchema, UnsubscribeRequestSchema } from '@modelcontextprotocol/sdk/types';`,
        `import { subscribeToResource, unsubscribeFromResource } from './resources/index.js';`
      );
    }
  }

  if (config.capabilities.prompts) {
    imports.push(
      `import { ListPromptsRequestSchema, GetPromptRequestSchema } from '@modelcontextprotocol/sdk/types';`,
      `import { listPrompts, getPrompt } from './prompts/index.js';`
    );
  }

  const handlers: string[] = [];

  if (config.capabilities.tools) {
    handlers.push(
      `// Tools handlers`,
      `server.setRequestHandler(ListToolsRequestSchema, listTools);`,
      `server.setRequestHandler(CallToolRequestSchema, callTool);`
    );
  }

  if (config.capabilities.resources) {
    handlers.push(
      `// Resources handlers`,
      `server.setRequestHandler(ListResourcesRequestSchema, listResources);`,
      `server.setRequestHandler(ReadResourceRequestSchema, readResource);`
    );
    if (config.features.subscribe) {
      handlers.push(
        `server.setRequestHandler(SubscribeRequestSchema, subscribeToResource);`,
        `server.setRequestHandler(UnsubscribeRequestSchema, unsubscribeFromResource);`
      );
    }
  }

  if (config.capabilities.prompts) {
    handlers.push(
      `// Prompts handlers`,
      `server.setRequestHandler(ListPromptsRequestSchema, listPrompts);`,
      `server.setRequestHandler(GetPromptRequestSchema, getPrompt);`
    );
  }

  return `#!/usr/bin/env node
/**
 * ${config.description}
 *
 * MCP Server Implementation following Anthropic Model Context Protocol specification
 * Protocol Version: 2025-06-18
 *
 * Generated by MCP Builder
 */

${imports.join('\n')}

/**
 * Initialize MCP Server with capabilities
 */
const server = new Server(
  {
    name: '${config.name}',
    version: '1.0.0',
  },
  {
    capabilities: {
      ${capabilities.join(',\n      ')}
    }
  }
);

${handlers.join('\n')}

/**
 * Error handling
 */
server.onerror = (error) => {
  console.error('[MCP Error]', error);
};

/**
 * Graceful shutdown
 */
process.on('SIGINT', async () => {
  await server.close();
  process.exit(0);
});

/**
 * Start server on stdio transport
 */
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('${config.name} MCP server running on stdio');
}

main().catch((error: Error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
`;
}
